
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>markov_helpers.graphs.MultiDiGraph &#8212; Markov Python Helpers  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="markov_helpers.markov" href="markov_helpers.markov.html" />
    <link rel="prev" title="markov_helpers.graphs.GraphAttrs" href="markov_helpers.graphs.GraphAttrs.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="markov-helpers-graphs-multidigraph">
<h1>markov_helpers.graphs.MultiDiGraph<a class="headerlink" href="#markov-helpers-graphs-multidigraph" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">MultiDiGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">incoming_graph_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://networkx.org/documentation/stable/reference/classes/multidigraph.html#networkx.MultiDiGraph" title="(in NetworkX v2.6.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">networkx.classes.multidigraph.MultiDiGraph</span></code></a>, <a class="reference internal" href="markov_helpers.graphs.GraphAttrs.html#markov_helpers.graphs.GraphAttrs" title="markov_helpers.graphs._tricks.GraphAttrs"><code class="xref py py-class docutils literal notranslate"><span class="pre">markov_helpers.graphs._tricks.GraphAttrs</span></code></a></p>
<p>Custom directed multi-graph class that remembers edge order (N,E)</p>
<p>Iterating over edges is done in the order that the edges were first added.
It also provides methods for working with <em class="xref py py-obj">np.ndarray`s of node/edge
attribute: `has_node_attr</em>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_node_attr" title="markov_helpers.graphs.MultiDiGraph.get_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_attr</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_node_attr" title="markov_helpers.graphs.MultiDiGraph.set_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_node_attr</span></code></a>,
<a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_edge_attr" title="markov_helpers.graphs.MultiDiGraph.has_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge_attr</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_edge_attr" title="markov_helpers.graphs.MultiDiGraph.get_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_attr</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_edge_attr" title="markov_helpers.graphs.MultiDiGraph.set_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_edge_attr</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adj" title="markov_helpers.graphs.MultiDiGraph.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adj</span></code></a></dt><dd><p>Graph adjacency object holding the neighbors of each node.</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.degree" title="markov_helpers.graphs.MultiDiGraph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a></dt><dd><p>A DegreeView for the Graph as G.degree or G.degree().</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edges" title="markov_helpers.graphs.MultiDiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></dt><dd><p>OutMultiEdgeView of the MultiDiGraph as G.edges or G.edges(…).</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_degree" title="markov_helpers.graphs.MultiDiGraph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></dt><dd><p>A DegreeView for (node, in_degree) or in_degree for single node.</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_edges" title="markov_helpers.graphs.MultiDiGraph.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a></dt><dd><p>An InMultiEdgeView of the Graph as G.in_edges or G.in_edges().</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.name" title="markov_helpers.graphs.MultiDiGraph.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>String identifier of the graph.</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a></dt><dd><p>A NodeView of the Graph as G.nodes or G.nodes().</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_degree" title="markov_helpers.graphs.MultiDiGraph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a></dt><dd><p>Returns an iterator for (node, out-degree) or out-degree for single node.</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_edges" title="markov_helpers.graphs.MultiDiGraph.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></dt><dd><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.pred" title="markov_helpers.graphs.MultiDiGraph.pred"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pred</span></code></a></dt><dd><p>Graph adjacency object holding the predecessors of each node.</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.succ" title="markov_helpers.graphs.MultiDiGraph.succ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">succ</span></code></a></dt><dd><p>Graph adjacency object holding the successors of each node.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="markov_helpers.graphs.MultiDiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a>(u_for_edge, v_for_edge[, key])</p></td>
<td><p>Add/modify an edge</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a>(ebunch_to_add, **attr)</p></td>
<td><p>Add all the edges in ebunch_to_add.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_node" title="markov_helpers.graphs.MultiDiGraph.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code></a>(node_for_adding, **attr)</p></td>
<td><p>Add a single node <em class="xref py py-obj">node_for_adding</em> and update node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_nodes_from" title="markov_helpers.graphs.MultiDiGraph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a>(nodes_for_adding, **attr)</p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></a>(ebunch_to_add[, weight])</p></td>
<td><p>Add weighted edges in <em class="xref py py-obj">ebunch_to_add</em> with specified weight attr</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adjacency" title="markov_helpers.graphs.MultiDiGraph.adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacency</span></code></a>()</p></td>
<td><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adjlist_inner_dict_factory" title="markov_helpers.graphs.MultiDiGraph.adjlist_inner_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjlist_inner_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adjlist_outer_dict_factory" title="markov_helpers.graphs.MultiDiGraph.adjlist_outer_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjlist_outer_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.clear" title="markov_helpers.graphs.MultiDiGraph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.clear_edges" title="markov_helpers.graphs.MultiDiGraph.clear_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_edges</span></code></a>()</p></td>
<td><p>Remove all edges from the graph without altering nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.copy" title="markov_helpers.graphs.MultiDiGraph.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([as_view])</p></td>
<td><p>Returns a copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_attr_dict_factory" title="markov_helpers.graphs.MultiDiGraph.edge_attr_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_attr_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_attr_matrix" title="markov_helpers.graphs.MultiDiGraph.edge_attr_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_attr_matrix</span></code></a>(data[, fill])</p></td>
<td><p>Collect values of edge attributes in an array of matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_key" title="markov_helpers.graphs.MultiDiGraph.edge_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_key</span></code></a>()</p></td>
<td><p>Vector of edge keys</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_key_dict_factory" title="markov_helpers.graphs.MultiDiGraph.edge_key_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_key_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_subgraph" title="markov_helpers.graphs.MultiDiGraph.edge_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_subgraph</span></code></a>(edges)</p></td>
<td><p>Returns the subgraph induced by the specified edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_edge_attr" title="markov_helpers.graphs.MultiDiGraph.get_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_attr</span></code></a>(data[, default])</p></td>
<td><p>Collect values of edge attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_edge_data" title="markov_helpers.graphs.MultiDiGraph.get_edge_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_data</span></code></a>(u, v[, key, default])</p></td>
<td><p>Returns the attribute dictionary associated with edge (u, v).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_node_attr" title="markov_helpers.graphs.MultiDiGraph.get_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_attr</span></code></a>(data[, default])</p></td>
<td><p>Collect values of node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.graph_attr_dict_factory" title="markov_helpers.graphs.MultiDiGraph.graph_attr_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">graph_attr_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_edge" title="markov_helpers.graphs.MultiDiGraph.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge</span></code></a>(u, v[, key])</p></td>
<td><p>Returns True if the graph has an edge between nodes u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_edge_attr" title="markov_helpers.graphs.MultiDiGraph.has_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge_attr</span></code></a>(data[, strict])</p></td>
<td><p>Test for existence of edge attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_node" title="markov_helpers.graphs.MultiDiGraph.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node</span></code></a>(n)</p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_node_attr" title="markov_helpers.graphs.MultiDiGraph.has_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node_attr</span></code></a>(data[, strict])</p></td>
<td><p>Test for existence of node attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_predecessor" title="markov_helpers.graphs.MultiDiGraph.has_predecessor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_predecessor</span></code></a>(u, v)</p></td>
<td><p>Returns True if node u has predecessor v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_successor" title="markov_helpers.graphs.MultiDiGraph.has_successor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_successor</span></code></a>(u, v)</p></td>
<td><p>Returns True if node u has successor v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.is_directed" title="markov_helpers.graphs.MultiDiGraph.is_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_directed</span></code></a>()</p></td>
<td><p>Returns True if graph is directed, False otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.is_multigraph" title="markov_helpers.graphs.MultiDiGraph.is_multigraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multigraph</span></code></a>()</p></td>
<td><p>Returns True if graph is a multigraph, False otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nbunch_iter" title="markov_helpers.graphs.MultiDiGraph.nbunch_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbunch_iter</span></code></a>([nbunch])</p></td>
<td><p>Returns an iterator over nodes contained in nbunch that are also in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.neighbors" title="markov_helpers.graphs.MultiDiGraph.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.new_edge_key" title="markov_helpers.graphs.MultiDiGraph.new_edge_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new_edge_key</span></code></a>(u, v)</p></td>
<td><p>Returns an unused key for edges between nodes <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.node_attr_dict_factory" title="markov_helpers.graphs.MultiDiGraph.node_attr_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_attr_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.node_dict_factory" title="markov_helpers.graphs.MultiDiGraph.node_dict_factory"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_dict_factory</span></code></a></p></td>
<td><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_edges" title="markov_helpers.graphs.MultiDiGraph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a>([u, v])</p></td>
<td><p>Returns the number of edges between two nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_nodes" title="markov_helpers.graphs.MultiDiGraph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.order" title="markov_helpers.graphs.MultiDiGraph.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a>()</p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.predecessors" title="markov_helpers.graphs.MultiDiGraph.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over predecessor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edge" title="markov_helpers.graphs.MultiDiGraph.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a>(u, v[, key])</p></td>
<td><p>Remove an edge between u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edges_from" title="markov_helpers.graphs.MultiDiGraph.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a>(ebunch)</p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_node" title="markov_helpers.graphs.MultiDiGraph.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code></a>(n)</p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_nodes_from" title="markov_helpers.graphs.MultiDiGraph.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code></a>(nodes)</p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.reverse" title="markov_helpers.graphs.MultiDiGraph.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>([copy])</p></td>
<td><p>Returns the reverse of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_edge_attr" title="markov_helpers.graphs.MultiDiGraph.set_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_edge_attr</span></code></a>(data, values)</p></td>
<td><p>Collect values of edge attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_node_attr" title="markov_helpers.graphs.MultiDiGraph.set_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_node_attr</span></code></a>(data, values)</p></td>
<td><p>Change values of node attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.size" title="markov_helpers.graphs.MultiDiGraph.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a>([weight])</p></td>
<td><p>Returns the number of edges or total of all edge weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.subgraph" title="markov_helpers.graphs.MultiDiGraph.subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraph</span></code></a>(nodes)</p></td>
<td><p>Returns a SubGraph view of the subgraph induced on <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.successors" title="markov_helpers.graphs.MultiDiGraph.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code></a>(n)</p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_directed" title="markov_helpers.graphs.MultiDiGraph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a>([as_view])</p></td>
<td><p>Returns a directed representation of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_directed_class" title="markov_helpers.graphs.MultiDiGraph.to_directed_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed_class</span></code></a>()</p></td>
<td><p>Returns the class to use for empty directed copies.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_undirected" title="markov_helpers.graphs.MultiDiGraph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code></a>([reciprocal, as_view])</p></td>
<td><p>Returns an undirected representation of the digraph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_undirected_class" title="markov_helpers.graphs.MultiDiGraph.to_undirected_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected_class</span></code></a>()</p></td>
<td><p>Returns the class to use for empty undirected copies.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.update" title="markov_helpers.graphs.MultiDiGraph.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>([edges, nodes])</p></td>
<td><p>Update the graph using nodes/edges/graphs as input.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="markov_helpers.graphs.MultiDiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></p></td>
<td><p>Add/modify an edge</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></p></td>
<td><p>Add all the edges in ebunch_to_add.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_node" title="markov_helpers.graphs.MultiDiGraph.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code></a></p></td>
<td><p>Add a single node <em class="xref py py-obj">node_for_adding</em> and update node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_nodes_from" title="markov_helpers.graphs.MultiDiGraph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></p></td>
<td><p>Add multiple nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></a></p></td>
<td><p>Add weighted edges in <em class="xref py py-obj">ebunch_to_add</em> with specified weight attr</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adjacency" title="markov_helpers.graphs.MultiDiGraph.adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacency</span></code></a></p></td>
<td><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.clear" title="markov_helpers.graphs.MultiDiGraph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a></p></td>
<td><p>Remove all nodes and edges from the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.clear_edges" title="markov_helpers.graphs.MultiDiGraph.clear_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_edges</span></code></a></p></td>
<td><p>Remove all edges from the graph without altering nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.copy" title="markov_helpers.graphs.MultiDiGraph.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a></p></td>
<td><p>Returns a copy of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_attr_matrix" title="markov_helpers.graphs.MultiDiGraph.edge_attr_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_attr_matrix</span></code></a></p></td>
<td><p>Collect values of edge attributes in an array of matrices.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_key" title="markov_helpers.graphs.MultiDiGraph.edge_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_key</span></code></a></p></td>
<td><p>Vector of edge keys</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_subgraph" title="markov_helpers.graphs.MultiDiGraph.edge_subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_subgraph</span></code></a></p></td>
<td><p>Returns the subgraph induced by the specified edges.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_edge_attr" title="markov_helpers.graphs.MultiDiGraph.get_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_attr</span></code></a></p></td>
<td><p>Collect values of edge attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_edge_data" title="markov_helpers.graphs.MultiDiGraph.get_edge_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_edge_data</span></code></a></p></td>
<td><p>Returns the attribute dictionary associated with edge (u, v).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.get_node_attr" title="markov_helpers.graphs.MultiDiGraph.get_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_node_attr</span></code></a></p></td>
<td><p>Collect values of node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_edge" title="markov_helpers.graphs.MultiDiGraph.has_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge</span></code></a></p></td>
<td><p>Returns True if the graph has an edge between nodes u and v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_edge_attr" title="markov_helpers.graphs.MultiDiGraph.has_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_edge_attr</span></code></a></p></td>
<td><p>Test for existence of edge attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_node" title="markov_helpers.graphs.MultiDiGraph.has_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node</span></code></a></p></td>
<td><p>Returns True if the graph contains the node n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_node_attr" title="markov_helpers.graphs.MultiDiGraph.has_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_node_attr</span></code></a></p></td>
<td><p>Test for existence of node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_predecessor" title="markov_helpers.graphs.MultiDiGraph.has_predecessor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_predecessor</span></code></a></p></td>
<td><p>Returns True if node u has predecessor v.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.has_successor" title="markov_helpers.graphs.MultiDiGraph.has_successor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_successor</span></code></a></p></td>
<td><p>Returns True if node u has successor v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.is_directed" title="markov_helpers.graphs.MultiDiGraph.is_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_directed</span></code></a></p></td>
<td><p>Returns True if graph is directed, False otherwise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.is_multigraph" title="markov_helpers.graphs.MultiDiGraph.is_multigraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multigraph</span></code></a></p></td>
<td><p>Returns True if graph is a multigraph, False otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nbunch_iter" title="markov_helpers.graphs.MultiDiGraph.nbunch_iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbunch_iter</span></code></a></p></td>
<td><p>Returns an iterator over nodes contained in nbunch that are also in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.neighbors" title="markov_helpers.graphs.MultiDiGraph.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors</span></code></a></p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.new_edge_key" title="markov_helpers.graphs.MultiDiGraph.new_edge_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new_edge_key</span></code></a></p></td>
<td><p>Returns an unused key for edges between nodes <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_edges" title="markov_helpers.graphs.MultiDiGraph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a></p></td>
<td><p>Returns the number of edges between two nodes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_nodes" title="markov_helpers.graphs.MultiDiGraph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a></p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.order" title="markov_helpers.graphs.MultiDiGraph.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></p></td>
<td><p>Returns the number of nodes in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.predecessors" title="markov_helpers.graphs.MultiDiGraph.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></p></td>
<td><p>Returns an iterator over predecessor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edge" title="markov_helpers.graphs.MultiDiGraph.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a></p></td>
<td><p>Remove an edge between u and v.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edges_from" title="markov_helpers.graphs.MultiDiGraph.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a></p></td>
<td><p>Remove all edges specified in ebunch.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_node" title="markov_helpers.graphs.MultiDiGraph.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code></a></p></td>
<td><p>Remove node n.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_nodes_from" title="markov_helpers.graphs.MultiDiGraph.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code></a></p></td>
<td><p>Remove multiple nodes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.reverse" title="markov_helpers.graphs.MultiDiGraph.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a></p></td>
<td><p>Returns the reverse of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_edge_attr" title="markov_helpers.graphs.MultiDiGraph.set_edge_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_edge_attr</span></code></a></p></td>
<td><p>Collect values of edge attributes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.set_node_attr" title="markov_helpers.graphs.MultiDiGraph.set_node_attr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_node_attr</span></code></a></p></td>
<td><p>Change values of node attributes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.size" title="markov_helpers.graphs.MultiDiGraph.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></p></td>
<td><p>Returns the number of edges or total of all edge weights.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.subgraph" title="markov_helpers.graphs.MultiDiGraph.subgraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subgraph</span></code></a></p></td>
<td><p>Returns a SubGraph view of the subgraph induced on <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.successors" title="markov_helpers.graphs.MultiDiGraph.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code></a></p></td>
<td><p>Returns an iterator over successor nodes of n.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_directed" title="markov_helpers.graphs.MultiDiGraph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a></p></td>
<td><p>Returns a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_directed_class" title="markov_helpers.graphs.MultiDiGraph.to_directed_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed_class</span></code></a></p></td>
<td><p>Returns the class to use for empty directed copies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_undirected" title="markov_helpers.graphs.MultiDiGraph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code></a></p></td>
<td><p>Returns an undirected representation of the digraph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_undirected_class" title="markov_helpers.graphs.MultiDiGraph.to_undirected_class"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected_class</span></code></a></p></td>
<td><p>Returns the class to use for empty undirected copies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.update" title="markov_helpers.graphs.MultiDiGraph.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a></p></td>
<td><p>Update the graph using nodes/edges/graphs as input.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.adj" title="markov_helpers.graphs.MultiDiGraph.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adj</span></code></a></p></td>
<td><p>Graph adjacency object holding the neighbors of each node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.degree" title="markov_helpers.graphs.MultiDiGraph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a></p></td>
<td><p>A DegreeView for the Graph as G.degree or G.degree().</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edges" title="markov_helpers.graphs.MultiDiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></p></td>
<td><p>OutMultiEdgeView of the MultiDiGraph as G.edges or G.edges(...).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_degree" title="markov_helpers.graphs.MultiDiGraph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></p></td>
<td><p>A DegreeView for (node, in_degree) or in_degree for single node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_edges" title="markov_helpers.graphs.MultiDiGraph.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a></p></td>
<td><p>An InMultiEdgeView of the Graph as G.in_edges or G.in_edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.name" title="markov_helpers.graphs.MultiDiGraph.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></p></td>
<td><p>String identifier of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a></p></td>
<td><p>A NodeView of the Graph as G.nodes or G.nodes().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_degree" title="markov_helpers.graphs.MultiDiGraph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a></p></td>
<td><p>Returns an iterator for (node, out-degree) or out-degree for single node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_edges" title="markov_helpers.graphs.MultiDiGraph.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></p></td>
<td><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.pred" title="markov_helpers.graphs.MultiDiGraph.pred"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pred</span></code></a></p></td>
<td><p>Graph adjacency object holding the predecessors of each node.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.succ" title="markov_helpers.graphs.MultiDiGraph.succ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">succ</span></code></a></p></td>
<td><p>Graph adjacency object holding the successors of each node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edge_order" title="markov_helpers.graphs.MultiDiGraph.edge_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_order</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u_for_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_for_edge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add/modify an edge</p>
<p>The nodes u and v will be automatically added if they are
not already in the graph.</p>
<p>Edge attributes can be specified with keywords or by directly
accessing the edge’s attribute dictionary. See examples below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u_for_edge, v_for_edge</strong><span class="classifier">nodes</span></dt><dd><p>Nodes can be, for example, strings or numbers.
Nodes must be hashable (and not None) Python objects.</p>
</dd>
<dt><strong>key</strong><span class="classifier">hashable identifier, optional</span></dt><dd><p>Used to distinguish multiedges between a pair of nodes.
By default lowest unused integer</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional</span></dt><dd><p>Edge data (or labels or objects) can be assigned using
keyword arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">hashable identifier</span></dt><dd><p>The edge key assigned to the edge.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>~Key</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.add_edges_from">
<span class="sig-name descname"><span class="pre">add_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch_to_add</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all the edges in ebunch_to_add.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ebunch_to_add</strong><span class="classifier">container of edges</span></dt><dd><p>Each edge given in the container will be added to the
graph. The edges can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>2-tuples (u, v) or</p></li>
<li><p>3-tuples (u, v, d) for an edge data dict d, or</p></li>
<li><p>3-tuples (u, v, k) for not iterable key k, or</p></li>
<li><p>4-tuples (u, v, k, d) for an edge with data and key k</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional</span></dt><dd><p>Edge data (or labels or objects) can be assigned using
keyword arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A list of edge keys assigned to the edges in <em class="xref py py-obj">ebunch</em>.</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="markov_helpers.graphs.MultiDiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></dt><dd><p>add a single edge</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_weighted_edges_from</span></code></a></dt><dd><p>convenient way to add weighted edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding the same edge twice has no effect but any edge data
will be updated when each duplicate edge is added.</p>
<p>Edge attributes specified in an ebunch take precedence over
attributes specified via keyword arguments.</p>
<p>Default keys are generated using the method <code class="docutils literal notranslate"><span class="pre">new_edge_key()</span></code>.
This method can be overridden by subclassing the base class and
providing a custom <code class="docutils literal notranslate"><span class="pre">new_edge_key()</span></code> method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># using a list of edge tuples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># Add the path graph 0-1-2-3</span>
</pre></div>
</div>
<p>Associate data to edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;WN2898&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.add_node">
<span class="sig-name descname"><span class="pre">add_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_for_adding</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a single node <em class="xref py py-obj">node_for_adding</em> and update node attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>node_for_adding</strong><span class="classifier">node</span></dt><dd><p>A node can be any hashable Python object except None.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional</span></dt><dd><p>Set or change node attributes using key=value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_nodes_from" title="markov_helpers.graphs.MultiDiGraph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>A hashable object is one that can be used as a key in a Python
dictionary. This includes strings, numbers, tuples of strings
and numbers, etc.</p>
<p>On many platforms hashable items also include mutables such as
NetworkX Graphs, though one should be careful that the hash
doesn’t change on mutables.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Use keywords set/change node attributes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">UTM</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;13S&quot;</span><span class="p">,</span> <span class="mi">382871</span><span class="p">,</span> <span class="mi">3972649</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes_for_adding</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.add_nodes_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Add multiple nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes_for_adding</strong><span class="classifier">iterable container</span></dt><dd><p>A container of nodes (list, dict, set, etc.).
OR
A container of (node, attribute dict) tuples.
Node attributes are updated using the attribute dict.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional (default= no attributes)</span></dt><dd><p>Update attributes for all nodes in nodes.
Node attributes specified in nodes as a tuple take
precedence over attributes specified via keyword arguments.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_node" title="markov_helpers.graphs.MultiDiGraph.add_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_node</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[0, 1, 2, &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;o&#39;]</span>
</pre></div>
</div>
<p>Use keywords to update specific node attributes for every node.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
</pre></div>
</div>
<p>Use (node, attrdict) tuples to update attributes for specific nodes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">11</span><span class="p">)),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="s2">&quot;blue&quot;</span><span class="p">})])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;size&quot;</span><span class="p">]</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from">
<span class="sig-name descname"><span class="pre">add_weighted_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch_to_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weight'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">attr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.add_weighted_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Add weighted edges in <em class="xref py py-obj">ebunch_to_add</em> with specified weight attr</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ebunch_to_add</strong><span class="classifier">container of edges</span></dt><dd><p>Each edge given in the list or container will be added
to the graph. The edges must be given as 3-tuples (u, v, w)
where w is a number.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string, optional (default= ‘weight’)</span></dt><dd><p>The attribute name for the edge weights to be added.</p>
</dd>
<dt><strong>attr</strong><span class="classifier">keyword arguments, optional (default= no attributes)</span></dt><dd><p>Edge attributes to add/update for all edges.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="markov_helpers.graphs.MultiDiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a></dt><dd><p>add a single edge</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add multiple edges</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Adding the same edge twice for Graph/DiGraph simply updates
the edge data. For MultiGraph/MultiDiGraph, duplicate edges
are stored.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.adj">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">adj</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the neighbors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <em class="xref py py-obj">G.adj[3][2][0][‘color’] = ‘blue’</em> sets
the color of the edge <em class="xref py py-obj">(3, 2, 0)</em> to <em class="xref py py-obj">“blue”</em>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<em class="xref py py-obj">for nbr, datadict in G.adj[n].items():</em>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <em class="xref py py-obj">for nbr, foovalue in G[node].data(‘foo’, default=1):</em> works.</p>
<p>For directed graphs, <em class="xref py py-obj">G.adj</em> holds outgoing (successor) info.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.adjacency">
<span class="sig-name descname"><span class="pre">adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.adjacency" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over (node, adjacency dict) tuples for all nodes.</p>
<p>For directed graphs, only outgoing neighbors/adjacencies are included.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>adj_iter</strong><span class="classifier">iterator</span></dt><dd><p>An iterator over (node, adjacency dictionary) for all nodes in
the graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">nbrdict</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrdict</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adjacency</span><span class="p">()]</span>
<span class="go">[(0, {1: {}}), (1, {0: {}, 2: {}}), (2, {1: {}, 3: {}}), (3, {2: {}})]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.adjlist_inner_dict_factory">
<span class="sig-name descname"><span class="pre">adjlist_inner_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.adjlist_inner_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.adjlist_outer_dict_factory">
<span class="sig-name descname"><span class="pre">adjlist_outer_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.adjlist_outer_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all nodes and edges from the graph.</p>
<p>This also removes the name, and all graph, node, and edge attributes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.clear_edges">
<span class="sig-name descname"><span class="pre">clear_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.clear_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all edges from the graph without altering nodes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the graph.</p>
<p>The copy method by default returns an independent shallow copy
of the graph and attributes. That is, if an attribute is a
container, that container is shared by the original an the copy.
Use Python’s <a class="reference external" href="https://docs.python.org/3/library/copy.html#copy.deepcopy" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy.deepcopy</span></code></a> for new containers.</p>
<p>If <em class="xref py py-obj">as_view</em> is True then a view is returned instead of a copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>as_view</strong><span class="classifier">bool, optional (default=False)</span></dt><dd><p>If True, the returned graph-view provides a read-only view
of the original graph without actually copying any data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">Graph</span></dt><dd><p>A copy of the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.to_directed" title="markov_helpers.graphs.MultiDiGraph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a></dt><dd><p>return a directed copy of the graph.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>All copies reproduce the graph structure, but data attributes
may be handled in different ways. There are four types of copies
of a graph that people might want.</p>
<p>Deepcopy – A “deepcopy” copies the graph structure as well as
all data attributes and any objects they might contain.
The entire graph object is new so that changes in the copy
do not affect the original object. (see Python’s copy.deepcopy)</p>
<p>Data Reference (Shallow) – For a shallow copy the graph structure
is copied but the edge, node and graph attribute dicts are
references to those in the original graph. This saves
time and memory but could cause confusion if you change an attribute
in one graph and it changes the attribute in the other.
NetworkX does not provide this level of shallow copy.</p>
<p>Independent Shallow – This copy creates new independent attribute
dicts and then does a shallow copy of the attributes. That is, any
attributes that are containers are shared between the new graph
and the original. This is exactly what <em class="xref py py-obj">dict.copy()</em> provides.
You can obtain this style copy using:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">as_view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>Fresh Data – For fresh data, the graph structure is copied while
new empty data attribute dicts are created. The resulting graph
is independent of the original and it has no edge, node or graph
attributes. Fresh copies are not enabled. Instead use:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
<p>View – Inspired by dict-views, graph-views act like read-only
versions of the original graph, providing a copy of the original
structure without requiring any memory for copying the information.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.degree">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">degree</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>A DegreeView for the Graph as G.degree or G.degree().</p>
<p>The node degree is the number of edges adjacent to the node.
The weighted node degree is the sum of the edge weights for
edges incident to that node.</p>
<p>This object provides an iterator for (node, degree) as well as
lookup for the degree for a single node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string or None, optional (default=None)</span></dt><dd><p>The name of an edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights adjacent to the node.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>If a single nodes is requested</dt><dd></dd>
<dt><strong>deg</strong><span class="classifier">int</span></dt><dd><p>Degree of the node</p>
</dd>
<dt>OR if multiple nodes are requested</dt><dd></dd>
<dt><strong>nd_iter</strong><span class="classifier">iterator</span></dt><dd><p>The iterator returns two-tuples of (node, degree).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_degree" title="markov_helpers.graphs.MultiDiGraph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_degree" title="markov_helpers.graphs.MultiDiGraph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (1, 2), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_attr_dict_factory">
<span class="sig-name descname"><span class="pre">edge_attr_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_attr_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_attr_matrix">
<span class="sig-name descname"><span class="pre">edge_attr_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_attr_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect values of edge attributes in an array of matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute to use for matrix elements.</p>
</dd>
<dt><strong>fill</strong><span class="classifier">Number</span></dt><dd><p>Value given to missing edges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mat</strong><span class="classifier">np.ndarray (K,N,N)</span></dt><dd><p>Matrices of edge attribute values. Each matrix in the array
corresponds to a value of <em class="xref py py-obj">list_edge_keys(self)</em>, in that order.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_key">
<span class="sig-name descname"><span class="pre">edge_key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Vector of edge keys</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>keys</strong><span class="classifier">np.ndarray (E,)</span></dt><dd><p>Vector of keys for each edge, in the order edges were first added.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_key_dict_factory">
<span class="sig-name descname"><span class="pre">edge_key_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_key_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_order">
<span class="sig-name descname"><span class="pre">edge_order</span></span><em class="property"><span class="pre">:</span> <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">markov_helpers.graphs._tricks.Node</span><span class="p"><span class="pre">,</span> </span><span class="pre">markov_helpers.graphs._tricks.Node</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edge_subgraph">
<span class="sig-name descname"><span class="pre">edge_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edge_subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subgraph induced by the specified edges.</p>
<p>The induced subgraph contains each edge in <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edges" title="markov_helpers.graphs.MultiDiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a> and each
node incident to any one of those edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">iterable</span></dt><dd><p>An iterable of edges in this graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">Graph</span></dt><dd><p>An edge-induced subgraph of this graph with the same edge
attributes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The graph, edge, and node attributes in the returned subgraph
view are references to the corresponding attributes in the original
graph. The view is read-only.</p>
<p>To create a full graph version of the subgraph with its own copy
of the edge or node attributes, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edge_subgraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (3, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.edges">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">edges</span></span><em class="property"><span class="pre">:</span> <span class="pre">markov_helpers.graphs._tricks.OutMultiEdgeView</span></em><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>OutMultiEdgeView of the MultiDiGraph as G.edges or G.edges(…).</p>
<p>This property provides a <em class="xref py py-obj">dict/set</em>-like view of the graph’s edge,
with tuples <em class="xref py py-obj">(u,v)</em> or <em class="xref py py-obj">(u,v,key)</em> as keys and <em class="xref py py-obj">(u,v,key,data)</em> as
set-members. Iterating over edges is done in the order that the edges
were first added.</p>
<p>Calling this property with optional arguments <em class="xref py py-obj">data</em>, <em class="xref py py-obj">default</em> and
<em class="xref py py-obj">keys</em> controls the form of the tuple. Optional argument <em class="xref py py-obj">nbunch</em>
allows restriction to edges only involving certain nodes.
If <em class="xref py py-obj">data is False</em> (the default) then iterate over 2-tuples <em class="xref py py-obj">(u, v)</em>.
If <em class="xref py py-obj">data is True</em> iterate over 3-tuples <em class="xref py py-obj">(u, v, datadict)</em>.
Otherwise iterate over <em class="xref py py-obj">(u, v, datadict.get(data, default))</em>.
If <em class="xref py py-obj">keys is True</em>, replace <em class="xref py py-obj">u, v</em> with <em class="xref py py-obj">u, v, key</em> above.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">OutMultiEdgeView</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.get_edge_attr">
<span class="sig-name descname"><span class="pre">get_edge_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.get_edge_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect values of edge attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>default</strong><span class="classifier">Number, optional</span></dt><dd><p>Value to use for nodes without that attribute, by default <em class="xref py py-obj">nan</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">np.ndarray (E,)</span></dt><dd><p>Vector of edge attribute values.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.get_edge_data">
<span class="sig-name descname"><span class="pre">get_edge_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.get_edge_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the attribute dictionary associated with edge (u, v).</p>
<p>This is identical to <em class="xref py py-obj">G[u][v][key]</em> except the default is returned
instead of an exception is the edge doesn’t exist.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd></dd>
<dt><strong>default</strong><span class="classifier">any Python object (default=None)</span></dt><dd><p>Value to return if the edge (u, v) is not found.</p>
</dd>
<dt><strong>key</strong><span class="classifier">hashable identifier, optional (default=None)</span></dt><dd><p>Return data only for the edge with specified key.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>edge_dict</strong><span class="classifier">dictionary</span></dt><dd><p>The edge attribute dictionary.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>  <span class="c1"># key=&#39;a&#39;</span>
<span class="go">{&#39;weight&#39;: 7}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">]</span>  <span class="c1"># key=&#39;a&#39;</span>
<span class="go">{&#39;weight&#39;: 7}</span>
</pre></div>
</div>
<p>Warning: we protect the graph data structure by making
<em class="xref py py-obj">G.edges</em> and <em class="xref py py-obj">G[1][2]</em> read-only dict-like structures.
However, you can assign values to attributes in e.g.
<em class="xref py py-obj">G.edges[1, 2, ‘a’]</em> or <em class="xref py py-obj">G[1][2][‘a’]</em> using an additional
bracket as shown next. You need to specify all edge info
to assign to the edge data associated with an edge.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
<span class="go">10</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">{0: {}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># tuple form</span>
<span class="go">{0: {}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">get_edge_data</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># edge not in graph, return 0</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.get_node_attr">
<span class="sig-name descname"><span class="pre">get_node_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.get_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect values of node attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>default</strong><span class="classifier">Number, optional</span></dt><dd><p>Value to use for nodes without that attribute, by default <em class="xref py py-obj">nan</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vec</strong><span class="classifier">np.ndarray (N,)</span></dt><dd><p>Vector of node attribute values.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.21)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.graph_attr_dict_factory">
<span class="sig-name descname"><span class="pre">graph_attr_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.graph_attr_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_edge">
<span class="sig-name descname"><span class="pre">has_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the graph has an edge between nodes u and v.</p>
<p>This is the same as <em class="xref py py-obj">v in G[u] or key in G[u][v]</em>
without KeyError exceptions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd><p>Nodes can be, for example, strings or numbers.</p>
</dd>
<dt><strong>key</strong><span class="classifier">hashable identifier, optional (default=None)</span></dt><dd><p>If specified return True only if the edge with
key is found.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>edge_ind</strong><span class="classifier">bool</span></dt><dd><p>True if edge is in the graph, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Can be called either using two nodes u, v, an edge tuple (u, v),
or an edge tuple (u, v, key).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># using two nodes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1">#  e is a 2-tuple (u, v)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>  <span class="c1"># specify key</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># e is a 3-tuple (u, v, &#39;a&#39;)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following syntax are equivalent:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># though this gives :exc:`KeyError` if 0 not in G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_edge_attr">
<span class="sig-name descname"><span class="pre">has_edge_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_edge_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for existence of edge attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool, optopnal</span></dt><dd><p>Only <em class="xref py py-obj">True</em> if every edge has the attribute. By default <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>has</strong><span class="classifier">bool</span></dt><dd><p><em class="xref py py-obj">True</em> when some/every edge has the attribute, <em class="xref py py-obj">False</em> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_node">
<span class="sig-name descname"><span class="pre">has_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the graph contains the node n.</p>
<p>Identical to <em class="xref py py-obj">n in G</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">node</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is more readable and simpler to use</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">G</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_node_attr">
<span class="sig-name descname"><span class="pre">has_node_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for existence of node attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>strict</strong><span class="classifier">bool, optional</span></dt><dd><p>Only <em class="xref py py-obj">True</em> if every node has the attribute. By default <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>has</strong><span class="classifier">bool</span></dt><dd><p><em class="xref py py-obj">True</em> when some/every node has the attribute, <em class="xref py py-obj">False</em> otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_predecessor">
<span class="sig-name descname"><span class="pre">has_predecessor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_predecessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if node u has predecessor v.</p>
<p>This is true if graph has the edge u&lt;-v.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.has_successor">
<span class="sig-name descname"><span class="pre">has_successor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.has_successor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if node u has successor v.</p>
<p>This is true if graph has the edge u-&gt;v.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.in_degree">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">in_degree</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.in_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>A DegreeView for (node, in_degree) or in_degree for single node.</p>
<p>The node in-degree is the number of edges pointing in to the node.
The weighted node degree is the sum of the edge weights for
edges incident to that node.</p>
<p>This object provides an iterator for (node, degree) as well as
lookup for the degree for a single node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string or None, optional (default=None)</span></dt><dd><p>The edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights adjacent to the node.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>If a single node is requested</dt><dd></dd>
<dt><strong>deg</strong><span class="classifier">int</span></dt><dd><p>Degree of the node</p>
</dd>
<dt>OR if multiple nodes are requested</dt><dd></dd>
<dt><strong>nd_iter</strong><span class="classifier">iterator</span></dt><dd><p>The iterator returns two-tuples of (node, in-degree).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.degree" title="markov_helpers.graphs.MultiDiGraph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_degree" title="markov_helpers.graphs.MultiDiGraph.out_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_degree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 0</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">in_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 0), (1, 1), (2, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.in_edges">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">in_edges</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.in_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>An InMultiEdgeView of the Graph as G.in_edges or G.in_edges().</p>
<p>in_edges(self, nbunch=None, data=False, keys=False, default=None)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
<dt><strong>data</strong><span class="classifier">string or bool, optional (default=False)</span></dt><dd><p>The edge attribute returned in 3-tuple (u, v, ddict[data]).
If True, return edge attribute dict in 3-tuple (u, v, ddict).
If False, return 2-tuple (u, v).</p>
</dd>
<dt><strong>keys</strong><span class="classifier">bool, optional (default=False)</span></dt><dd><p>If True, return edge keys with each edge.</p>
</dd>
<dt><strong>default</strong><span class="classifier">value, optional (default=None)</span></dt><dd><p>Value used for edges that don’t have the requested attribute.
Only relevant if data is not True or False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>in_edges</strong><span class="classifier">InMultiEdgeView</span></dt><dd><p>A view of edge attributes, usually it iterates over (u, v)
or (u, v, k) or (u, v, k, d) tuples of edges, but can also be
used for attribute lookup as <em class="xref py py-obj">edges[u, v, k][‘foo’]</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edges" title="markov_helpers.graphs.MultiDiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.is_directed">
<span class="sig-name descname"><span class="pre">is_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.is_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if graph is directed, False otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.is_multigraph">
<span class="sig-name descname"><span class="pre">is_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.is_multigraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if graph is a multigraph, False otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.name">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.name" title="Permalink to this definition">¶</a></dt>
<dd><p>String identifier of the graph.</p>
<p>This graph attribute appears in the attribute dict G.graph
keyed by the string <em class="xref py py-obj">“name”</em>. as well as an attribute (technically
a property) <em class="xref py py-obj">G.name</em>. This is entirely user controlled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.nbunch_iter">
<span class="sig-name descname"><span class="pre">nbunch_iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nbunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.nbunch_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over nodes contained in nbunch that are
also in the graph.</p>
<p>The nodes in nbunch are checked for membership in the graph
and if not are silently ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>niter</strong><span class="classifier">iterator</span></dt><dd><p>An iterator over nodes in nbunch that are also in the graph.
If nbunch is None, iterate over all nodes in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If nbunch is not a node or sequence of nodes.
If a node in nbunch is not hashable.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Graph.__iter__</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When nbunch is an iterator, the returned iterator yields values
directly from nbunch, becoming exhausted when nbunch is exhausted.</p>
<p>To test whether nbunch is a single node, one can use
“if nbunch in self:”, even after processing with this routine.</p>
<p>If nbunch is not a node or a (possibly empty) sequence/iterator
or None, a <code class="xref py py-exc docutils literal notranslate"><span class="pre">NetworkXError</span></code> is raised.  Also, if any object in
nbunch is not hashable, a <code class="xref py py-exc docutils literal notranslate"><span class="pre">NetworkXError</span></code> is raised.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.neighbors">
<span class="sig-name descname"><span class="pre">neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over successor nodes of n.</p>
<p>A successor of n is a node m such that there exists a directed
edge from n to m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.predecessors" title="markov_helpers.graphs.MultiDiGraph.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>neighbors() and successors() are the same.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.new_edge_key">
<span class="sig-name descname"><span class="pre">new_edge_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.new_edge_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an unused key for edges between nodes <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em>.</p>
<p>The nodes <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em> do not need to be already in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>key</strong><span class="classifier">int</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In the standard MultiGraph class the new key is the number of existing
edges between <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em> (increased if necessary to ensure unused).
The first edge will have key 0, then 1, etc. If an edge is removed
further new_edge_keys may not be in this order.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.node_attr_dict_factory">
<span class="sig-name descname"><span class="pre">node_attr_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.node_attr_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.node_dict_factory">
<span class="sig-name descname"><span class="pre">node_dict_factory</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.node_dict_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.nodes">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">nodes</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>A NodeView of the Graph as G.nodes or G.nodes().</p>
<p>Can be used as <em class="xref py py-obj">G.nodes</em> for data lookup and for set-like operations.
Can also be used as <em class="xref py py-obj">G.nodes(data=’color’, default=None)</em> to return a
NodeDataView which reports specific node data but no set operations.
It presents a dict-like interface as well with <em class="xref py py-obj">G.nodes.items()</em>
iterating over <em class="xref py py-obj">(node, nodedata)</em> 2-tuples and <em class="xref py py-obj">G.nodes[3][‘foo’]</em>
providing the value of the <em class="xref py py-obj">foo</em> attribute for node <em class="xref py py-obj">3</em>. In addition,
a view <em class="xref py py-obj">G.nodes.data(‘foo’)</em> provides a dict-like interface to the
<em class="xref py py-obj">foo</em> attribute of each node. <em class="xref py py-obj">G.nodes.data(‘foo’, default=1)</em>
provides a default for nodes that do not have attribute <em class="xref py py-obj">foo</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">string or bool, optional (default=False)</span></dt><dd><p>The node attribute returned in 2-tuple (n, ddict[data]).
If True, return entire node attribute dict as (n, ddict).
If False, return just the nodes n.</p>
</dd>
<dt><strong>default</strong><span class="classifier">value, optional (default=None)</span></dt><dd><p>Value used for nodes that don’t have the requested attribute.
Only relevant if data is not True or False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>NodeView</dt><dd><p>Allows set-like operations over the nodes as well as node
attribute dict lookup and calling to get a NodeDataView.
A NodeDataView iterates over <em class="xref py py-obj">(n, data)</em> and has no set operations.
A NodeView iterates over <em class="xref py py-obj">n</em> and includes set operations.</p>
<p>When called, if data is False, an iterator over nodes.
Otherwise an iterator of 2-tuples (node, attribute value)
where the attribute is specified in <em class="xref py py-obj">data</em>.
If data is True then the attribute becomes the
entire data dictionary.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If your node data is not needed, it is simpler and equivalent
to use the expression <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">G</span></code>, or <code class="docutils literal notranslate"><span class="pre">list(G)</span></code>.</p>
<p class="rubric">Examples</p>
<p>There are two simple ways of getting a list of all nodes in the graph:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>To get the node data along with the nodes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s2">&quot;5pm&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, {&#39;foo&#39;: &#39;bar&#39;}), (1, {&#39;time&#39;: &#39;5pm&#39;}), (2, {})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
<span class="go">[(0, {&#39;foo&#39;: &#39;bar&#39;}), (1, {&#39;time&#39;: &#39;5pm&#39;}), (2, {})]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;bar&#39;), (1, None), (2, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;bar&#39;), (1, None), (2, None)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">))</span>
<span class="go">[(0, None), (1, &#39;5pm&#39;), (2, None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">))</span>
<span class="go">[(0, None), (1, &#39;5pm&#39;), (2, None)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;Not Available&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;Not Available&#39;), (1, &#39;5pm&#39;), (2, &#39;Not Available&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;Not Available&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;Not Available&#39;), (1, &#39;5pm&#39;), (2, &#39;Not Available&#39;)]</span>
</pre></div>
</div>
<p>If some of your nodes have an attribute and the rest are assumed
to have a default attribute value you can create a dictionary
from node/attribute pairs using the <em class="xref py py-obj">default</em> keyword argument
to guarantee the value is never None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">{0: 1, 1: 2, 2: 3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.number_of_edges">
<span class="sig-name descname"><span class="pre">number_of_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.number_of_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges between two nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes, optional (Gefault=all edges)</span></dt><dd><p>If u and v are specified, return the number of edges between
u and v. Otherwise return the total number of all edges.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nedges</strong><span class="classifier">int</span></dt><dd><p>The number of edges in the graph.  If nodes <em class="xref py py-obj">u</em> and <em class="xref py py-obj">v</em> are
specified return the number of edges between those nodes. If
the graph is directed, this only returns the number of edges
from <em class="xref py py-obj">u</em> to <em class="xref py py-obj">v</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.size" title="markov_helpers.graphs.MultiDiGraph.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>For undirected multigraphs, this method counts the total number
of edges in the graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">[0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>If you specify two nodes, this counts the total number of edges
joining the two nodes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For directed multigraphs, this method can count the total number
of directed edges from <em class="xref py py-obj">u</em> to <em class="xref py py-obj">v</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="go">[0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.number_of_nodes">
<span class="sig-name descname"><span class="pre">number_of_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.number_of_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nnodes</strong><span class="classifier">int</span></dt><dd><p>The number of nodes in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.order" title="markov_helpers.graphs.MultiDiGraph.order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">order</span></code></a></dt><dd><p>identical method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">__len__</span></code></dt><dd><p>identical method</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of nodes in the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nnodes</strong><span class="classifier">int</span></dt><dd><p>The number of nodes in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_nodes" title="markov_helpers.graphs.MultiDiGraph.number_of_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_nodes</span></code></a></dt><dd><p>identical method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">__len__</span></code></dt><dd><p>identical method</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.out_degree">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">out_degree</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.out_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for (node, out-degree) or out-degree for single node.</p>
<p>out_degree(self, nbunch=None, weight=None)</p>
<p>The node out-degree is the number of edges pointing out of the node.
This function returns the out-degree for a single node or an iterator
for a bunch of nodes or if nothing is passed as argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string or None, optional (default=None)</span></dt><dd><p>The edge attribute that holds the numerical value used
as a weight.  If None, then each edge has weight 1.
The degree is the sum of the edge weights.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>If a single node is requested</dt><dd></dd>
<dt><strong>deg</strong><span class="classifier">int</span></dt><dd><p>Degree of the node</p>
</dd>
<dt>OR if multiple nodes are requested</dt><dd></dd>
<dt><strong>nd_iter</strong><span class="classifier">iterator</span></dt><dd><p>The iterator returns two-tuples of (node, out-degree).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.degree" title="markov_helpers.graphs.MultiDiGraph.degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_degree" title="markov_helpers.graphs.MultiDiGraph.in_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_degree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># node 0 with degree 1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (1, 1), (2, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.out_edges">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">out_edges</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.out_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>An OutMultiEdgeView of the Graph as G.edges or G.edges().</p>
<p>edges(self, nbunch=None, data=False, keys=False, default=None)</p>
<p>The OutMultiEdgeView provides set-like operations on the edge-tuples
as well as edge attribute lookup. When called, it also provides
an EdgeDataView object which allows control of access to edge
attributes (but does not provide set-like operations).
Hence, <em class="xref py py-obj">G.edges[u, v][‘color’]</em> provides the value of the color
attribute for edge <em class="xref py py-obj">(u, v)</em> while
<em class="xref py py-obj">for (u, v, c) in G.edges(data=’color’, default=’red’):</em>
iterates through all the edges yielding the color attribute
with default <em class="xref py py-obj">‘red’</em> if no color attribute exists.</p>
<p>Edges are returned as tuples with optional data and keys
in the order (node, neighbor, key, data).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nbunch</strong><span class="classifier">single node, container, or all nodes (default= all nodes)</span></dt><dd><p>The view will only report edges incident to these nodes.</p>
</dd>
<dt><strong>data</strong><span class="classifier">string or bool, optional (default=False)</span></dt><dd><p>The edge attribute returned in 3-tuple (u, v, ddict[data]).
If True, return edge attribute dict in 3-tuple (u, v, ddict).
If False, return 2-tuple (u, v).</p>
</dd>
<dt><strong>keys</strong><span class="classifier">bool, optional (default=False)</span></dt><dd><p>If True, return edge keys with each edge.</p>
</dd>
<dt><strong>default</strong><span class="classifier">value, optional (default=None)</span></dt><dd><p>Value used for edges that don’t have the requested attribute.
Only relevant if data is not True or False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">EdgeView</span></dt><dd><p>A view of edge attributes, usually it iterates over (u, v)
(u, v, k) or (u, v, k, d) tuples of edges, but can also be
used for attribute lookup as <em class="xref py py-obj">edges[u, v, k][‘foo’]</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.in_edges" title="markov_helpers.graphs.MultiDiGraph.in_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">in_edges</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.out_edges" title="markov_helpers.graphs.MultiDiGraph.out_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">out_edges</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Nodes in nbunch that are not in the graph will be (quietly) ignored.
For directed graphs this returns the out-edges.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="go">[(0, 1), (1, 2), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default data is {} (empty dict)</span>
<span class="go">[(0, 1, {}), (1, 2, {}), (2, 3, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(0, 1, 1), (1, 2, 1), (2, 3, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># default keys are integers</span>
<span class="go">[(0, 1, 0), (1, 2, 0), (2, 3, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, {}), (1, 2, 0, {}), (2, 3, 0, {&#39;weight&#39;: 5})]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 1, 0, 1), (1, 2, 0, 1), (2, 3, 0, 5)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(0, 1), (2, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.pred">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">pred</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the predecessors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <em class="xref py py-obj">G.adj[3][2][0][‘color’] = ‘blue’</em> sets
the color of the edge <em class="xref py py-obj">(3, 2, 0)</em> to <em class="xref py py-obj">“blue”</em>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<em class="xref py py-obj">for nbr, datadict in G.adj[n].items():</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.predecessors">
<span class="sig-name descname"><span class="pre">predecessors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over predecessor nodes of n.</p>
<p>A predecessor of n is a node m such that there exists a directed
edge from m to n.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.successors" title="markov_helpers.graphs.MultiDiGraph.successors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">successors</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.remove_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an edge between u and v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>u, v</strong><span class="classifier">nodes</span></dt><dd><p>Remove an edge between nodes u and v.</p>
</dd>
<dt><strong>key</strong><span class="classifier">hashable identifier, optional (default=None)</span></dt><dd><p>Used to distinguish multiple edges between a pair of nodes.
If None remove a single (arbitrary) edge between u and v.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If there is not an edge between u and v, or
if there is no edge with the specified key.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edges_from" title="markov_helpers.graphs.MultiDiGraph.remove_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edges_from</span></code></a></dt><dd><p>remove a collection of edges</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>  <span class="c1"># unpacks e from an edge tuple</span>
</pre></div>
</div>
<p>For multiple edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># key_list returned</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># remove a single (arbitrary) edge</span>
</pre></div>
</div>
<p>For edges with keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
<span class="go">&#39;first&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;second&quot;</span><span class="p">)</span>
<span class="go">&#39;second&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;second&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.remove_edges_from">
<span class="sig-name descname"><span class="pre">remove_edges_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ebunch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.remove_edges_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all edges specified in ebunch.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ebunch: list or container of edge tuples</strong></dt><dd><p>Each edge given in the list or container will be removed
from the graph. The edges can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>2-tuples (u, v) All edges between u and v are removed.</p></li>
<li><p>3-tuples (u, v, key) The edge identified by key is removed.</p></li>
<li><p>4-tuples (u, v, key, data) where data is ignored.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_edge" title="markov_helpers.graphs.MultiDiGraph.remove_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_edge</span></code></a></dt><dd><p>remove a single edge</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Will fail silently if an edge in ebunch is not in the graph.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebunch</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">ebunch</span><span class="p">)</span>
</pre></div>
</div>
<p>Removing multiple copies of edges</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keys</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">[(1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># silently ignore extra copy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>  <span class="c1"># now empty graph</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.remove_node">
<span class="sig-name descname"><span class="pre">remove_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.remove_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove node n.</p>
<p>Removes the node n and all adjacent edges.
Attempting to remove a non-existent node will raise an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_nodes_from" title="markov_helpers.graphs.MultiDiGraph.remove_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_nodes_from</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.remove_nodes_from">
<span class="sig-name descname"><span class="pre">remove_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.remove_nodes_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove multiple nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">iterable container</span></dt><dd><p>A container of nodes (list, dict, set, etc.).  If a node
in the container is not in the graph it is silently ignored.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.remove_node" title="markov_helpers.graphs.MultiDiGraph.remove_node"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_node</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.reverse">
<span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reverse of the graph.</p>
<p>The reverse is a graph with the same nodes and edges
but with the directions of the edges reversed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>copy</strong><span class="classifier">bool optional (default=True)</span></dt><dd><p>If True, return a new DiGraph holding the reversed edges.
If False, the reverse graph is created using a view of
the original graph.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.set_edge_attr">
<span class="sig-name descname"><span class="pre">set_edge_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.set_edge_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect values of edge attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>values</strong><span class="classifier">ndarray (E,)</span></dt><dd><p>Value to assign to the attribute for each edge.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.set_node_attr">
<span class="sig-name descname"><span class="pre">set_node_attr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.set_node_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Change values of node attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">str</span></dt><dd><p>Name of attribute.</p>
</dd>
<dt><strong>values</strong><span class="classifier">ndarray (N,)</span></dt><dd><p>Value to assign to the attribute for each node.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.10)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges or total of all edge weights.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weight</strong><span class="classifier">string or None, optional (default=None)</span></dt><dd><p>The edge attribute that holds the numerical value used
as a weight. If None, then each edge has weight 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>size</strong><span class="classifier">numeric</span></dt><dd><p>The number of edges or
(if weight keyword is provided) the total weight sum.</p>
<p>If weight is None, returns an int. Otherwise a float
(or more general numeric if the weights are more general).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.number_of_edges" title="markov_helpers.graphs.MultiDiGraph.number_of_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">number_of_edges</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="s2">&quot;weight&quot;</span><span class="p">)</span>
<span class="go">6.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.subgraph">
<span class="sig-name descname"><span class="pre">subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SubGraph view of the subgraph induced on <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a>.</p>
<p>The induced subgraph of the graph contains the nodes in <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a>
and the edges between those nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nodes</strong><span class="classifier">list, iterable</span></dt><dd><p>A container of nodes which will be iterated through once.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">SubGraph View</span></dt><dd><p>A subgraph view of the graph. The graph structure cannot be
changed but node/edge attributes can and are shared with the
original graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The graph, edge and node attributes are shared with the original graph.
Changes to the graph structure is ruled out by the view, but changes
to attributes are reflected in the original graph.</p>
<p>To create a subgraph with its own copy of the edge/node attributes use:
G.subgraph(nodes).copy()</p>
<p>For an inplace reduction of a graph to a subgraph you can remove nodes:
G.remove_nodes_from([n for n in G if n not in set(nodes)])</p>
<p>Subgraph views are sometimes NOT what you want. In most cases where
you want to do more than simply look at the induced edges, it makes
more sense to just create the subgraph as its own graph with code like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a subgraph SG based on a (possibly multigraph) G</span>
<span class="n">SG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
<span class="n">SG</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span><span class="p">)</span>
<span class="k">if</span> <span class="n">SG</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
    <span class="n">SG</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">keydict</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">keydict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">SG</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">largest_wcc</span>
        <span class="k">for</span> <span class="n">nbr</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">largest_wcc</span><span class="p">)</span>
<span class="n">SG</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># or DiGraph, MultiGraph, MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.succ">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">succ</span></span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.succ" title="Permalink to this definition">¶</a></dt>
<dd><p>Graph adjacency object holding the successors of each node.</p>
<p>This object is a read-only dict-like structure with node keys
and neighbor-dict values.  The neighbor-dict is keyed by neighbor
to the edgekey-dict.  So <em class="xref py py-obj">G.adj[3][2][0][‘color’] = ‘blue’</em> sets
the color of the edge <em class="xref py py-obj">(3, 2, 0)</em> to <em class="xref py py-obj">“blue”</em>.</p>
<p>Iterating over G.adj behaves like a dict. Useful idioms include
<em class="xref py py-obj">for nbr, datadict in G.adj[n].items():</em>.</p>
<p>The neighbor information is also provided by subscripting the graph.
So <em class="xref py py-obj">for nbr, foovalue in G[node].data(‘foo’, default=1):</em> works.</p>
<p>For directed graphs, <em class="xref py py-obj">G.succ</em> is identical to <em class="xref py py-obj">G.adj</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.successors">
<span class="sig-name descname"><span class="pre">successors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over successor nodes of n.</p>
<p>A successor of n is a node m such that there exists a directed
edge from n to m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">node</span></dt><dd><p>A node in the graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>NetworkXError</dt><dd><p>If n is not in the graph.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.predecessors" title="markov_helpers.graphs.MultiDiGraph.predecessors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">predecessors</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>neighbors() and successors() are the same.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.to_directed">
<span class="sig-name descname"><span class="pre">to_directed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.to_directed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a directed representation of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">MultiDiGraph</span></dt><dd><p>A directed graph with the same name, same nodes, and with
each edge (u, v, data) replaced by two directed edges
(u, v, data) and (v, u, data).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This returns a “deepcopy” of the edge, node, and
graph attributes which attempts to completely copy
all of the data and references.</p>
<p>This is in contrast to the similar D=DiGraph(G) which returns a
shallow copy of the data.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<p>Warning: If you have subclassed MultiGraph to use dict-like objects
in the data structure, those changes do not transfer to the
MultiDiGraph created by this method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  <span class="c1"># or MultiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 0)]</span>
</pre></div>
</div>
<p>If already directed, return a (deep) copy</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>  <span class="c1"># or MultiDiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.to_directed_class">
<span class="sig-name descname"><span class="pre">to_directed_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.to_directed_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the class to use for empty directed copies.</p>
<p>If you subclass the base classes, use this to designate
what directed class to use for <em class="xref py py-obj">to_directed()</em> copies.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.to_undirected">
<span class="sig-name descname"><span class="pre">to_undirected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reciprocal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.to_undirected" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an undirected representation of the digraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reciprocal</strong><span class="classifier">bool (optional)</span></dt><dd><p>If True only keep edges that appear in both directions
in the original digraph.</p>
</dd>
<dt><strong>as_view</strong><span class="classifier">bool (optional, default=False)</span></dt><dd><p>If True return an undirected view of the original directed graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">MultiGraph</span></dt><dd><p>An undirected graph with the same name and nodes and
with edge (u, v, data) if either (u, v, data) or (v, u, data)
is in the digraph.  If both edges exist in digraph and
their edge data is different, only one edge is created
with an arbitrary choice of which edge data to use.
You must check and correct for this manually if desired.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiGraph</span></code>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.copy" title="markov_helpers.graphs.MultiDiGraph.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edge" title="markov_helpers.graphs.MultiDiGraph.add_edge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edge</span></code></a>, <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This returns a “deepcopy” of the edge, node, and
graph attributes which attempts to completely copy
all of the data and references.</p>
<p>This is in contrast to the similar D=MultiDiGraph(G) which
returns a shallow copy of the data.</p>
<p>See the Python copy module for more information on shallow
and deep copies, <a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a>.</p>
<p>Warning: If you have subclassed MultiDiGraph to use dict-like
objects in the data structure, those changes do not transfer
to the MultiGraph created by this method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># or MultiGraph, etc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G2</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">G2</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[(0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.to_undirected_class">
<span class="sig-name descname"><span class="pre">to_undirected_class</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.to_undirected_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the class to use for empty undirected copies.</p>
<p>If you subclass the base classes, use this to designate
what directed class to use for <em class="xref py py-obj">to_directed()</em> copies.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="markov_helpers.graphs.MultiDiGraph.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#markov_helpers.graphs.MultiDiGraph.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the graph using nodes/edges/graphs as input.</p>
<p>Like dict.update, this method takes a graph as input, adding the
graph’s nodes and edges to this graph. It can also take two inputs:
edges and nodes. Finally it can take either edges or nodes.
To specify only nodes the keyword <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a> must be used.</p>
<p>The collections of edges and nodes are treated similarly to
the add_edges_from/add_nodes_from methods. When iterated, they
should yield 2-tuples (u, v) or 3-tuples (u, v, datadict).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>edges</strong><span class="classifier">Graph object, collection of edges, or None</span></dt><dd><p>The first parameter can be a graph or some edges. If it has
attributes <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a> and <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.edges" title="markov_helpers.graphs.MultiDiGraph.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a>, then it is taken to be a
Graph-like object and those attributes are used as collections
of nodes and edges to be added to the graph.
If the first parameter does not have those attributes, it is
treated as a collection of edges and added to the graph.
If the first argument is None, no edges are added.</p>
</dd>
<dt><strong>nodes</strong><span class="classifier">collection of nodes, or None</span></dt><dd><p>The second parameter is treated as a collection of nodes
to be added to the graph unless it is None.
If <em class="xref py py-obj">edges is None</em> and <em class="xref py py-obj">nodes is None</em> an exception is raised.
If the first parameter is a Graph, then <a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.nodes" title="markov_helpers.graphs.MultiDiGraph.nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nodes</span></code></a> is ignored.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_edges_from" title="markov_helpers.graphs.MultiDiGraph.add_edges_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_edges_from</span></code></a></dt><dd><p>add multiple edges to a graph</p>
</dd>
<dt><a class="reference internal" href="#markov_helpers.graphs.MultiDiGraph.add_nodes_from" title="markov_helpers.graphs.MultiDiGraph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a></dt><dd><p>add multiple nodes to a graph</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>It you want to update the graph using an adjacency structure
it is straightforward to obtain the edges/nodes from adjacency.
The following examples provide common cases, your adjacency may
be slightly different and require tweaks of these examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-set/list/tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-dict-of-attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">1.4</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># dict-of-dict-of-dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">}}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># predecessor adjacency (dict-of-set)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">3</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">pred</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># MultiGraph dict-of-dict-of-dict-of-attribute</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MDG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiDiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.3</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">}}},</span>
<span class="gp">... </span>    <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="mf">0.7</span><span class="p">}}},</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">nbrs</span> <span class="ow">in</span> <span class="n">adj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">keydict</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">ekey</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">keydict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MDG</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">complete_graph</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;power&quot;</span><span class="p">:</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">u</span> <span class="o">*</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="mi">225</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1000</span><span class="p">]</span>  <span class="c1"># for singleton, use a container</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Markov Python Helpers</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home page</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="markov_helpers.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="markov_helpers.html#notes">Notes</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="markov_helpers.graphs.html">markov_helpers.graphs</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.plots.html">markov_helpers.graphs.plots</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.list_edge_attrs.html">markov_helpers.graphs.list_edge_attrs</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.list_edge_keys.html">markov_helpers.graphs.list_edge_keys</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.list_node_attrs.html">markov_helpers.graphs.list_node_attrs</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.make_graph.html">markov_helpers.graphs.make_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.mat_to_graph.html">markov_helpers.graphs.mat_to_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.param_to_graph.html">markov_helpers.graphs.param_to_graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.DiGraph.html">markov_helpers.graphs.DiGraph</a></li>
<li class="toctree-l4"><a class="reference internal" href="markov_helpers.graphs.GraphAttrs.html">markov_helpers.graphs.GraphAttrs</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">markov_helpers.graphs.MultiDiGraph</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="markov_helpers.markov.html">markov_helpers.markov</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home page</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="markov_helpers.html">API reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="markov_helpers.html">markov_helpers</a><ul>
  <li><a href="markov_helpers.graphs.html">markov_helpers.graphs</a><ul>
      <li>Previous: <a href="markov_helpers.graphs.GraphAttrs.html" title="previous chapter">markov_helpers.graphs.GraphAttrs</a></li>
      <li>Next: <a href="markov_helpers.markov.html" title="next chapter">markov_helpers.markov</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Subhaneil Lahiri.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>